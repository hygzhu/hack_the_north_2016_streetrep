/*
Install the Firebase Node.js module with npm from the command line:

$ npm install firebase --save

To use the Firebase Node.js module in your application, require the Firebase module:

var firebase = require("firebase");

Then, initialize the Firebase SDK using the code snippet from above, which should look like this:

// Initialize Firebase
// TODO: Replace with your project's customized code snippet
var config = {
  apiKey: "<API_KEY>",
  authDomain: "<PROJECT_ID>.firebaseapp.com",
  databaseURL: "https://<DATABASE_NAME>.firebaseio.com",
  storageBucket: "<BUCKET>.appspot.com",
};
firebase.initializeApp(config);

Use Firebase services

A Firebase App can use multiple Firebase services. Each service can 
be accessed from the firebase namespace:

    firebase.auth() - Authentication
    firebase.storage() - Storage
    firebase.database() - Realtime Database

See the individual services for documentation on their use.
Run a Local Web Server for Development

If you are building a web app, you will find that some parts of the Firebase 
JavaScript SDK require that your web app be served from a server rather than 
from the local filesystem. You can use the Firebase CLI to run a local server like this:

$ npm install -g firebase-tools
$ firebase serve

Deploy your Web App Using Firebase Hosting

If you are building a web app and your web app is entirely static content, 
you can deploy it easily using Firebase Hosting.

Firebase Hosting is developer-focused static web hosting for modern front-end 
web applications. Using Firebase Hosting, you can deploy SSL-enabled web apps 
to your own domain on a global content-delivery network (CDN) from a single command.
Advanced Usage

For advanced developers, Firebase has the capability to access multiple Apps at a 
time, each with their own configuration information. Usually, a program will only 
have a single (default) App. In that case, you can use a shorthand notation, such 
as firebase.database(), to access individual services of the default App.

When you need to access services across multiple Firebase Apps, you do so via 
methods of each individual Firebase App:

  // Intialize the "[DEFAULT]" App
  var mainApp = firebase.initializeApp({
    // ...
  });

  // Intialize a "Secondary" App
  var secondaryApp = firebase.initializeApp({
    // ...
  }, "Secondary");

  // Each app has its own configuration options and authentication state
  mainApp.database().ref("path/to/data").set(value);
  secondaryApp.database().ref("path/to/data").set(anotherValue);


// Get a reference to the database service
  var database = firebase.database();


  ///////////////////////////////////////////////////////////////////////////////////////////////
SAVING DATA

 Save Data on the Web

There are four methods for writing data to the Firebase Realtime Database:
Method 	Common uses

set() 	Write or replace data to a defined path, such as users/<user-id>/<username>.
push() 	Add to a list of data. Every time you call push(), Firebase generates a unique key that 
        can also be used as a unique identifier, such as user-posts/<user-id>/<unique-post-id>.
update() 	Update some of the keys for a defined path without replacing all of the data.
transaction() 	Update complex data that could be corrupted by concurrent updates.

Note: By default, read and write access to your database is restricted so 
only authenticated users can read or write data. To get started without setting up Authentication, 
you can configure your rules for public access. This does make your database open to anyone, 
even people not using your app, so be sure to restrict your database again 
when you set up authentication.
Write, update, or delete data at a reference
Basic write operations

For basic write operations, you can use set() to save data to a specified reference, 
replacing any existing data at that path. For example a social blogging application might 
add a user with set() as follows:

function writeUserData(userId, name, email, imageUrl) {
  firebase.database().ref('users/' + userId).set({
    username: name,
    email: email,
    profile_picture : imageUrl
  });
}

Using set() overwrites data at the specified location, including any child nodes.
Append to a list of data

Use the push() method to append data to a list in multiuser applications. 
The push() method generates a unique key every time a new child is added to the 
specified Firebase reference. By using these auto-generated keys for each new element 
in the list, several clients can add children to the same location at the same time 
without write conflicts. The unique key generated by push() is based on a timestamp, 
so list items are automatically ordered chronologically.

You can use the reference to the new data returned by the push() method to get the 
value of the child's auto-generated key or set data for the child. The .key property of 
a push() reference contains the auto-generated key.

You can use these auto-generated keys to simplify flattening your data structure. 
For more information, see the data fan-out example.
Update specific fields

To simultaneously write to specific children of a node without overwriting other child 
nodes, use the update() method.

When calling update(), you can update lower-level child values by specifying a path 
for the key. If data is stored in multiple locations to scale better, you can update 
all instances of that data using data fan-out.

For example, a social blogging app might create a post and simultaneously update 
it to the recent activity feed and the posting user's activity feed using code like this:

function writeNewPost(uid, username, picture, title, body) {
  // A post entry.
  var postData = {
    author: username,
    uid: uid,
    body: body,
    title: title,
    starCount: 0,
    authorPic: picture
  };

  // Get a key for a new Post.
  var newPostKey = firebase.database().ref().child('posts').push().key;

  // Write the new post's data simultaneously in the posts list and the user's post list.
  var updates = {};
  updates['/posts/' + newPostKey] = postData;
  updates['/user-posts/' + uid + '/' + newPostKey] = postData;

  return firebase.database().ref().update(updates);
}

This example uses push() to create a post in the node containing posts for 
all users at /posts/$postid and simultaneously retrieve the key. The key can then 
be used to create a second entry in the user's posts at /user-posts/$userid/$postid.

Using these paths, you can perform simultaneous updates to multiple locations in the JSON 
tree with a single call to update(), such as how this example creates the new post in both 
locations. Simultaneous updates made this way are atomic: either all updates succeed or all updates fail.
Delete data

The simplest way to delete data is to call remove() on a reference to the location of that data.

You can also delete by specifying null as the value for another write operation such as set() 
or update(). You can use this technique with update() to delete multiple children in a single API call.
Receive a Promise

To know when your data is committed to the Firebase Realtime Database server, you can use a 
Promise. Both set() and update() can return a Promise you can use to know when the write is 
committed to the database.
Save data as transactions

When working with data that could be corrupted by concurrent modifications, such as 
incremental counters, you can use a transaction operation. You can give this operation 
an update function and an optional completion callback. The update function takes the 
current state of the data as an argument and returns the new desired state you would 
like to write. If another client writes to the location before your new value is successfully 
written, your update function is called again with the new current value, and the write is retried.

For instance, in the example social blogging app, you could allow users to star and unstar 
posts and keep track of how many stars a post has received as follows:

function toggleStar(postRef, uid) {
  postRef.transaction(function(post) {
    if (post) {
      if (post.stars && post.stars[uid]) {
        post.starCount--;
        post.stars[uid] = null;
      } else {
        post.starCount++;
        if (!post.stars) {
          post.stars = {};
        }
        post.stars[uid] = true;
      }
    }
    return post;
  });
}

Using a transaction prevents star counts from being incorrect if multiple 
users star the same post at the same time or the client had stale data. 
If the transaction is rejected, the server returns the current value to the 
client, which runs the transaction again with the updated value. This repeats 
until the transaction is accepted or you abort the transaction.
Note: Because your update function is called multiple times, it must be able 
to handle null data. Even if there is existing data in your remote database, 
it may not be locally cached when the transaction function is run, resulting 
in null for the initial value.
Write data offline

If a client loses its network connection, your app will continue functioning correctly.

Every client connected to a Firebase database maintains its own internal version 
of any active data. When data is written, it's written to this local version first. 
The Firebase client then synchronizes that data with the remote database servers and 
with other clients on a "best-effort" basis.

As a result, all writes to the database trigger local events immediately, before any 
data is written to the server. This means your app remains responsive regardless of network 
latency or connectivity.

Once connectivity is reestablished, your app receives the appropriate set of events so that 
the client syncs with the current server state, without having to write any custom code.
Note: The Firebase Realtime Database web APIs do not persist data offline outside of the session. 
In order for writes to be persisted to the server, the web page must not be closed before the data 
is written to the server.


////////////////////////////////////////////////////////////////////////////////////////////////

 Structure Your Database

This guide covers some of the key concepts in data architecture and best practices 
for structuring the JSON data in your Firebase Realtime Database.

Building a properly structured database requires quite a bit of forethought. 
Most importantly, you need to plan for how data is going to be saved and later 
retrieved to make that process as easy as possible.
How data is structured: it's a JSON tree

All Firebase Realtime Database data is stored as JSON objects. You can think of the 
database as a cloud-hosted JSON tree. Unlike a SQL database, there are no tables or records. 
When you add data to the JSON tree, it becomes a node in the existing JSON structure with 
an associated key. You can provide your own keys, such as user IDs or semantic names, or 
they can be provided for you using push().

If you create your own keys, they must be UTF-8 encoded, can be a maximum of 768 bytes, 
and cannot contain ., $, #, [, ], /, or ASCII control characters 0-31 or 127.

For example, consider a chat application that allows users to store a basic profile 
and contact list. A typical user profile is located at a path, such as /users/$uid. 
The user alovelace might have a database entry that looks something like this:

{
  "users": {
    "alovelace": {
      "name": "Ada Lovelace",
      "contacts": { "ghopper": true },
    },
    "ghopper": { ... },
    "eclarke": { ... }
  }
}

Although the database uses a JSON tree, data stored in the database can be 
represented as certain native types that correspond to available JSON types 
to help you write more maintainable code. For more information, see Save Data.
Best practices for data structure
Avoid nesting data

Because the Firebase Realtime Database allows nesting data up to 32 levels deep, 
you might be tempted to think that this should be the default structure. However, 
when you fetch data at a location in your database, you also retrieve all of its 
child nodes. In addition, when you grant someone read or write access at a node in 
your database, you also grant them access to all data under that node. Therefore, 
in practice, it's best to keep your data structure as flat as possible.

For an example of why nested data is bad, consider the following multiply-nested structure:

{
  // This is a poorly nested data architecture, because iterating the children
  // of the "chats" node to get a list of conversation titles requires
  // potentially downloading hundreds of megabytes of messages
  "chats": {
    "one": {
      "title": "Historical Tech Pioneers",
      "messages": {
        "m1": { "sender": "ghopper", "message": "Relay malfunction found. Cause: moth." },
        "m2": { ... },
        // a very long list of messages
      }
    },
    "two": { ... }
  }
}

With this nested design, iterating through the data becomes problematic. For example, 
listing the titles of chat conversations requires the entire chats tree, including all 
members and messages, to be downloaded to the client.
Flatten data structures

If the data is instead split into separate paths, also called denormalization, it can be 
efficiently downloaded in separate calls, as it is needed. Consider this flattened structure:

{
  // Chats contains only meta info about each conversation
  // stored under the chats's unique ID
  "chats": {
    "one": {
      "title": "Historical Tech Pioneers",
      "lastMessage": "ghopper: Relay malfunction found. Cause: moth.",
      "timestamp": 1459361875666
    },
    "two": { ... },
    "three": { ... }
  },

  // Conversation members are easily accessible
  // and stored by chat conversation ID
  "members": {
    // we'll talk about indices like this below
    "one": {
      "ghopper": true,
      "alovelace": true,
      "eclarke": true
    },
    "two": { ... },
    "three": { ... }
  },

  // Messages are separate from data we may want to iterate quickly
  // but still easily paginated and queried, and organized by chat
  // conversation ID
  "messages": {
    "one": {
      "m1": {
        "name": "eclarke",
        "message": "The relay seems to be malfunctioning.",
        "timestamp": 1459361875337
      },
      "m2": { ... },
      "m3": { ... }
    },
    "two": { ... },
    "three": { ... }
  }
}

It's now possible to iterate through the list of rooms by downloading only a few 
bytes per conversation, quickly fetching metadata for listing or displaying rooms in a UI. 
Messages can be fetched separately and displayed as they arrive, allowing the UI to stay 
responsive and fast.
Create data that scales

When building apps, it's often better to download a subset of a list. This is particularly 
common if the list contains thousands of records. When this relationship is static and one-directional, 
you can simply nest the child objects under the parent.

Sometimes, this relationship is more dynamic, or it may be necessary to denormalize this data. Many 
times you can denormalize the data by using a query to retrieve a subset of the data, as discussed 
in Retrieve Data.

But even this may be insufficient. Consider, for example, a two-way relationship between users and 
groups. Users can belong to a group, and groups comprise a list of users. When it comes time to 
decide which groups a user belongs to, things get complicated.

What's needed is an elegant way to list the groups a user belongs to and fetch only data for 
those groups. An index of groups can help a great deal here:

// An index to track Ada's memberships
{
  "users": {
    "alovelace": {
      "name": "Ada Lovelace",
      // Index Ada's groups in her profile
      "groups": {
         // the value here doesn't matter, just that the key exists
         "techpioneers": true,
         "womentechmakers": true
      }
    },
    ...
  },
  "groups": {
    "techpioneers": {
      "name": "Historical Tech Pioneers",
      "members": {
        "alovelace": true,
        "ghopper": true,
        "eclarke": true
      }
    },
    ...
  }
}

You might notice that this duplicates some data by storing the relationship under 
both Ada's record and under the group. Now alovelace is indexed under a group, and 
techpioneers is listed in Ada's profile. So to delete Ada from the group, it has 
to be updated in two places.

This is a necessary redundancy for two-way relationships. It allows you to quickly 
and efficiently fetch Ada's memberships, even when the list of users or groups scales 
into the millions or when Realtime Database security rules prevent access to some of the records.

This approach, inverting the data by listing the IDs as keys and setting the value to 
true, makes checking for a key as simple as reading /users/$uid/groups/$group_id and 
checking if it is null. The index is faster and a good deal more efficient than 
querying or scanning the data.


////////////////////////////////////////////////////////////////////////////////////////////////////
Retrieving:


 Retrieve Data on the Web

This document covers the basics of retrieving data and how to order and filter Firebase data.

Firebase data is retrieved by attaching an asynchronous listener to a firebase.database.Reference. 
The listener is triggered once for the initial state of the data and again anytime the data changes.
Note: By default, read and write access to your database is restricted so only authenticated users 
can read or write data. To get started without setting up Authentication, you can configure your 
rules for public access. This does make your database open to anyone, even people not using your 
app, so be sure to restrict your database again when you set up authentication.
Listen for events

You can listen for these types of events that retrieve data:
Event 	Typical usage
value 	Read and listen for changes to the entire contents of a path.
child_added 	Retrieve lists of items or listen for additions to a list of items. Suggested 
use with child_changed and child_removed to monitor changes to lists.
child_changed 	Listen for changes to the items in a list. Use with child_added and child_removed 
to monitor changes to lists.
child_removed 	Listen for items being removed from a list. Use with child_added and child_changed 
to monitor changes to lists.
child_moved 	Listen for changes to the order of items in an ordered list. child_moved events 
always follow the child_changed event that caused the item's order to change (based on your current 
order-by method).

To add an event listener, use the on() method.
Value events

You can use the value event to read a static snapshot of the contents at a given path, 
as they existed at the time of the event. This method is triggered once when the listener 
is attached and again every time the data, including children, changes. The event callback 
is passed a snapshot containing all data at that location, including child data. If there is 
no data, the snapshot returned is null.
Important: The value event is called every time data is changed at the specified database 
reference, including changes to children. To limit the size of your snapshots, attach only 
at the lowest level needed for watching changes. For example, attaching a listener to the 
root of your database is not recommended.

The following example demonstrates a social blogging application retrieving the star count 
of a post from the database:

var starCountRef = firebase.database().ref('posts/' + postId + '/starCount');
starCountRef.on('value', function(snapshot) {
  updateStarCount(postElement, snapshot.val());
});


Let's demonstrate the differences between callbacks and promises by building part of a blog webapp. Our first step is to fetch an articleâ€™s contents. Here is how it might look with callbacks:

ref.child('blogposts').child(id).once('value', function(snapshot) {
  // The callback succeeded; do something with the final result.
  renderBlog(snapshot.val());
}, function(error) {
  // The callback failed.
  console.error(error);
});
The Promise-based implementation is similar:

ref.child('blogposts').child(id).once('value').then(function(snapshot) {
  // The Promise was "fulfilled" (it succeeded).
  renderBlog(snapshot.val());
}, function(error) {
  // The Promise was rejected.
  console.error(error);
});















The listener receives a snapshot that contains the data at the specified location in the 
database at the time of the event. You can retrieve the data in the snapshot with the val() method.
Child events

Child events are triggered in response to specific operations that happen to the children 
of a node from an operation such as a new child added through the push() method or a child
 being updated through the update() method.

The child_added event is typically used to retrieve a list of items in a Firebase database.
 The child_added event is triggered once for each existing child and then again every time 
 a new child is added to the specified path. The listener is passed a snapshot containing 
 the new child's data.

The child_changed event is triggered any time a child node is modified. This includes any 
modifications to descendants of the child node. It is typically used in conjunction with 
the child_added and child_removed events to respond to changes to a list of items. The 
snapshot passed to the event listener contains the updated data for the child.

The child_removed event is triggered when an immediate child is removed. It is typically
 used in conjunction with the child_added and child_changed events. The snapshot passed 
 to the event event contains the data for the removed child.

The child_moved event is triggered whenever the child_changed event is triggered by an 
update that causes reordering of the child. It is used with data that is ordered with 
orderByChild or orderByValue.

Each of these together can be useful for listening to changes to a specific node in a 
database. For example, a social blogging app might use these methods together to monitor 
activity in the comments of a post, as shown below:

var commentsRef = firebase.database().ref('post-comments/' + postId);
commentsRef.on('child_added', function(data) {
  addCommentElement(postElement, data.key, data.val().text, data.val().author);
});

commentsRef.on('child_changed', function(data) {
  setCommentValues(postElement, data.key, data.val().text, data.val().author);
});

commentsRef.on('child_removed', function(data) {
  deleteComment(postElement, data.key);
});

Detach listeners

Callbacks are removed by calling the off() method on your Firebase database reference.

You can remove a single listener by passing it as a parameter to off(). 
Calling off() on the location with no arguments removes all listeners at that location.

Calling off() on a parent listener does not automatically remove listeners registered 
on its child nodes; off() must also be called on any child listeners to remove the callback.
Read data once

In some cases you may want a snapshot of your data without listening for changes, such
 as when initializing a UI element that you don't expect to change. You can use the 
 once() method to simplify this scenario: it triggers once and then does not trigger again.

This is useful for data that only needs to be loaded once and isn't expected to change 
frequently or require active listening. For instance, the blogging app in the previous 
examples uses this method to load a user's profile when they begin authoring a new post:

var userId = firebase.auth().currentUser.uid;
return firebase.database().ref('/users/' + userId).once('value').then(function(snapshot) {
  var username = snapshot.val().username;
  // ...
});

Sorting and filtering data

You can use the Realtime Database Query class to retrieve data sorted by key, 
by value, or by value of a child. You can also filter the sorted result to a 
specific number of results or a range of keys or values.
Note: Filtering and sorting can be expensive, especially when done on the client. 
If your app uses queries, define the .indexOn rule to index those keys on the server 
and improve query performance as described in Indexing Your Data.
Sort data

To retrieve sorted data, start by specifying one of the order-by methods to determine 
how results are ordered:
Method 	Usage
orderByChild() 	Order results by the value of a specified child key.
orderByKey() 	Order results by child keys.
orderByValue() 	Order results by child values.

You can only use one order-by method at a time. Calling an order-by method multiple 
times in the same query throws an error.

The following example demonstrates how you could retrieve a list of a user's top posts 
sorted by their star count:

var myUserId = firebase.auth().currentUser.uid;
var topUserPostsRef = firebase.database().ref('user-posts/' + myUserId).orderByChild('starCount');

This defines a query that when combined with a child listener synchronizes the client 
with the user's posts from the path in the database based on their user ID, ordered by 
the number of stars each post has received. This technique of using IDs as index keys is 
called data fan out, you can read more about it in Structure Your Database.

The call to the orderByChild() method specifies the child key to order the results by. In 
this case, posts are sorted by the value of the "starCount" child in each post. For more 
information on how other data types are ordered, see How query data is ordered.
Filtering data

To filter data, you can combine any of the limit or range methods with an order-by method 
when constructing a query.
Method 	Usage
limitToFirst() 	Sets the maximum number of items to return from the beginning of the ordered list of results.
limitToLast() 	Sets the maximum number of items to return from the end of the ordered list of results.
startAt() 	Return items greater than or equal to the specified key or value, depending on the order-by method chosen.
endAt() 	Return items less than or equal to the specified key or value, depending on the order-by method chosen.
equalTo() 	Return items equal to the specified key or value, depending on the order-by method chosen.

Unlike the order-by methods, you can combine multiple limit or range functions. 
For example, you can combine the startAt() and endAt() methods to limit the results 
to a specified range of values.
Limit the number of results

You can use the limitToFirst() and limitToLast() methods to set a maximum number of 
children to be synced for a given event. For example, if you use limitToFirst() to 
set a limit of 100, you initially only receive up to 100 child_added events. If you 
have fewer than 100 items stored in your Firebase database, a child_added event fires 
for each item.

As items change, you receive child_added events for items that enter the query and 
child_removed events for items that drop out of it so that the total number stays at 100.

The following example demonstrates how example blogging app defines a query to retrieve a 
list of the 100 most recent posts by all users:

var recentPostsRef = firebase.database().ref('posts').limitToLast(100);

This example only defines a query, to actually synchronize data it needs to have an attached listener.
Filter by key or value

You can use startAt(), endAt(), and equalTo() to choose arbitrary starting, ending, and 
equivalence points for queries. This can be useful for paginating data or finding items 
with children that have a specific value.
How query data is ordered

This section explains how data is sorted by each of the order-by methods in the Query class.
orderByChild

When using orderByChild(), data that contains the specified child key is ordered as follows:

    Children with a null value for the specified child key come first.
    Children with a value of false for the specified child key come next. If multiple children have a value of false, they are sorted lexicographically by key.
    Children with a value of true for the specified child key come next. If multiple children have a value of true, they are sorted lexicographically by key.
    Children with a numeric value come next, sorted in ascending order. If multiple children have the same numerical value for the specified child node, they are sorted by key.
    Strings come after numbers and are sorted lexicographically in ascending order. If multiple children have the same value for the specified child node, they are ordered lexicographically by key.
    Objects come last and are sorted lexicographically by key in ascending order.

orderByKey

When using orderByKey() to sort your data, data is returned in ascending order by key.

    Children with a key that can be parsed as a 32-bit integer come first, sorted in ascending order.
    Children with a string value as their key come next, sorted lexicographically in ascending order.

orderByValue

When using orderByValue(), children are ordered by their value. The ordering criteria are 
the same as in orderByChild(), except the value of the node is used instead of the value 
of a specified child key.

